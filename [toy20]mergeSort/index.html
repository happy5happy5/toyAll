<!DOCTYPE html>
<html>
  <body>
    <script type="text/javascript" src="main.js"></script>
    <div class="markdown-body">
      <h1>mergeSort</h1>
      <h2>문제</h2>
      <p>
        정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야
        합니다.
      </p>
      <h2>입력</h2>
      <h3>인자 1 : arr</h3>
      <ul>
        <li><code>number</code> 타입을 요소로 갖는 배열</li>
        <li><code>arr[i]</code>는 정수</li>
        <li><code>arr.length</code> 100,000 이하</li>
      </ul>
      <h2>출력</h2>
      <ul>
        <li><code>number</code> 타입을 요소로 갖는 배열을 리턴해야 합니다.</li>
        <li>배열의 요소는 오름차순으로 정렬되어야 합니다.</li>
        <li><code>arr[i] &lt;= arr[j]</code> (<code>i &lt; j</code>)</li>
      </ul>
      <h2>주의사항</h2>
      <ul>
        <li><strong>병합 정렬</strong>을 구현해야 합니다.</li>
        <li><code>arr.sort</code> 사용은 금지됩니다.</li>
        <li>입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.</li>
      </ul>
      <h2>입출력 예시</h2>
      <pre
        style="
          color: black;
          background: rgb(245, 242, 240);
          text-shadow: white 0px 1px;
          font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
          text-align: left;
          white-space: pre;
          word-spacing: normal;
          word-break: normal;
          overflow-wrap: normal;
          line-height: 1.5;
          tab-size: 4;
          hyphens: none;
          padding: 1em;
          margin: 0.5em 0px;
          overflow: auto;
        "
      ><code style="color: black; background: none; text-shadow: white 0px 1px; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none;"><span class="token" style="color: rgb(0, 119, 170);">let</span> output <span class="token" style="color: rgb(154, 110, 58); background: rgba(255, 255, 255, 0.5);">=</span> <span class="token" style="color: rgb(221, 74, 104);">mergeSort</span><span class="token" style="color: rgb(153, 153, 153);">(</span><span class="token" style="color: rgb(153, 153, 153);">[</span><span class="token" style="color: rgb(153, 0, 85);">3</span><span class="token" style="color: rgb(153, 153, 153);">,</span> <span class="token" style="color: rgb(153, 0, 85);">1</span><span class="token" style="color: rgb(153, 153, 153);">,</span> <span class="token" style="color: rgb(153, 0, 85);">21</span><span class="token" style="color: rgb(153, 153, 153);">]</span><span class="token" style="color: rgb(153, 153, 153);">)</span><span class="token" style="color: rgb(153, 153, 153);">;</span>
<span class="token console" style="color: rgb(221, 74, 104);">console</span><span class="token" style="color: rgb(153, 153, 153);">.</span><span class="token method property-access" style="color: rgb(221, 74, 104);">log</span><span class="token" style="color: rgb(153, 153, 153);">(</span>output<span class="token" style="color: rgb(153, 153, 153);">)</span><span class="token" style="color: rgb(153, 153, 153);">;</span> <span class="token" style="color: slategray;">// --&gt; [1, 3, 21]</span></code></pre>
      <h2>힌트</h2>
      <ul>
        <li>
          <p>
            병합 정렬은 표준 라이브러리에서 정렬을 구현할 때 퀵 정렬이나 힙
            정렬의 대안으로 사용하는 최적화된 정렬 알고리즘입니다. 병합 정렬은
            다음과 같은 알고리즘을 사용합니다.
          </p>
          <ol>
            <li>
              N의 길이를 가진 배열 리스트를 1의 길이를 가진 "부분 리스트"가 N개
              모인 것으로 취급합니다.
            </li>
            <li>
              인접한 부분 리스트들을 정렬하여 2의 길이를 가진 부분 리스트로
              병합합니다.
            </li>
            <li>
              2의 길이를 가진 인접한 부분 리스트들을 4의 길이를 가진 부분
              리스트로 합칩니다.
            </li>
            <li>하나의 정렬된 리스트가 될 때까지 위 과정을 반복합니다.</li>
            <li>
              N이 홀수라면, 첫 번째 병합 때 1의 길이를 가진 부분 리스트를
              남깁니다.
            </li>
          </ol>
        </li>
        <li>
          <p>
            병합 정렬은 두 가지 방식으로 구현 가능합니다. 재귀적
            접근(위-&gt;아래) 그리고 반복적 접근(아래-&gt;위)
          </p>
        </li>
      </ul>
      <p>반복적 접근</p>
      <pre
        style="
          color: black;
          background: rgb(245, 242, 240);
          text-shadow: white 0px 1px;
          font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
          text-align: left;
          white-space: pre;
          word-spacing: normal;
          word-break: normal;
          overflow-wrap: normal;
          line-height: 1.5;
          tab-size: 4;
          hyphens: none;
          padding: 1em;
          margin: 0.5em 0px;
          overflow: auto;
        "
      ><code style="color: black; background: none; text-shadow: white 0px 1px; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none;">1. 주어진 배열이 "정렬된" 부분 리스트로 나뉘어집니다.
[4,7,4,3,9,1,2] -&gt; [[4],[7],[4],[3],[9],[1],[2]]

2. 인접한 부분 리스트 2개가 정렬된 부분 리스트로 병합됩니다.
[[4],[7],[4],[3],[9],[1],[2]] -&gt; [[4,7],[3,4],[1,9],[2]]

2. 병합 과정 (반복) :
[[4,7],[3,4],[1,9],[2]] -&gt; [[3,4,4,7], [1,2,9]]

2. 병합 과정 (반복) :
[[3,4,4,7], [1,2,9]] -&gt; [[1,2,3,4,4,7,9]]

3. 마무리 : 정렬된 배열이 리턴됩니다.
[1,2,3,4,4,7,9]</code></pre>
      <p>재귀적 접근</p>
      <ol>
        <li>
          <p>
            주어진 배열을 절반으로 나눕니다.
            <a href="">4, 7, 4, 3, 9, 1, 2</a> -&gt; <a href="">4, 7, 4</a>,
            <a href="">3, 9, 1, 2</a>
          </p>
        </li>
        <li>
          <p>
            두 배열이 재귀적으로 정렬됩니다. <a href="">4, 7, 4</a> -&gt;
            <a href="">4, 4, 7</a> -&gt; <a href="">1, 2, 3, 9</a>
          </p>
        </li>
        <li>
          <p>
            두 배열이 병합됩니다. <a href="">4, 7, 4</a>,
            <a href="">3, 9, 1, 2</a> -&gt; <a href="">1, 2, 3, 4, 4, 7, 9</a>
          </p>
        </li>
      </ol>
      <p>
        2단계에서 나뉘어진 각각의 배열 <a href="">4, 7, 4</a>에 대해서도 1-3번의
        과정이 재귀적으로 똑같이 진행됩니다.
      </p>
      <ol>
        <li>
          <p>
            주어진 배열을 절반으로 나눕니다. <a href="">4, 7, 4</a> -&gt;
            <a href="">4</a>, <a href="">7, 4</a>
          </p>
        </li>
        <li>
          <p>
            두 배열이 재귀적으로 정렬됩니다. <a href="">4</a> -&gt;
            <a href="">4</a> -&gt; <a href="">4, 7</a>
          </p>
        </li>
        <li>
          <p>
            두 배열이 병합됩니다. <a href="">4</a>, <a href="">4, 7</a> -&gt;
            <a href="">4, 4, 7</a>
          </p>
        </li>
      </ol>
      <p>
        이 과정의 2단계에서 나뉘어진 <a href="">4, 7</a>에 대해서도 재귀가
        호출됩니다. <a href="">4</a>는 원소가 하나이기 때문에 정렬하지 않아도
        되겠죠?
      </p>
      <ol>
        <li>
          <p>
            주어진 배열을 절반으로 나눕니다. <a href="">7, 4</a> -&gt;
            <a href="">7</a>, <a href="">4</a>
          </p>
        </li>
        <li>
          <p>
            두 배열이 재귀적으로 정렬됩니다. <a href="">7</a> -&gt;
            <a href="">7</a> -&gt; <a href="">4</a>
          </p>
        </li>
        <li>
          <p>
            두 배열이 병합됩니다. <a href="">7</a>, <a href="">4</a> -&gt;
            <a href="">4, 7</a>
          </p>
        </li>
      </ol>
      <p>
        모든 재귀 호출이 완료되면 3단계에서 병합이 되기 때문에 최종적으로 정렬된
        하나의 배열이 리턴됩니다.
      </p>
    </div>
  </body>
</html>
